<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Oracle Data Guard</title>

		<meta name="author" content="Hakim El Hattab">

		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/moon.css" id="theme">

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
					<h1>Oracle Data Guard</h1>
					<br>
					<h3 style="color:#B2DFDB">Authors: Klaudia Olejniczak, Oleksandr Kuzhel</h3>
				</section>

				<section style="font-size:45px">
					<h2 style="color:#B2DFDB">Oracle Data Guard gwarantuje</h2>
					<ol>
						<li>Dostępność</li>
						<li>Ochronę danych </li>
						<!--(przeciwko data corruption)-->
						<li>Odzyskiwanie danych</li>
					</ol>
					<br>
					<br>
					<blockquote> &ldquo;
						Core reason for Data Guard is protecting against data loss, protecting against downtime.
						&rdquo;
					</blockquote>
				</section>


					<section>
						<h2 style="color:#B2DFDB">Konfiguracja Data Guard</h2>
						<p>Konfiguracja Data Guard składa się z : </p>
						<ul>
							<li>
							 <b>primary</b> (głównej) baz
							</li>
							<li>
								<b>standby</b>(zapasowej) bazy.
								<!--Conajmniej jednej!!!!-->
							</li>
						</ul>
						<P>
						Bazy danych w konfiguracji Oracle Data Guard są połączone za pomocą Oracle Net i mogą być rozproszone geograficznie.
						<!--
						Nie ma żadnych ograniczeń na to gdzie znajdują się bazy, jedyne wymaganie to żeby bazy mogły się lączyć między sobą.
							Na przykłąd:
								Można mieć jedną standby(zapasową) bazę i główną na tych samych systemach,
								a dwię inne instancje zapasowych na innych systemach w kompletnie innnych geograficznych lokacjach

						Zarówną główną jak i zapasowymi bazami danych
						 można zarządzać poprzez SQL command line
						 lub Data Guards broker interface,
						 albo UI zintegrowan z Oracle Enterprise Manager.
						-->
						</p>
					</section>

				<section>
					<h2 style="color:#B2DFDB">Primary Database</h2>
					<p> Konfiguracja Data Guard zawiera jedną produkcyjną bazę danych, lub odwołuje się do bazy danych, która funkcjonuje jako primary.

						<!--W przypadku gdy główna baza danych zostanie niedostępna  z powodu planowanej lub nieplanowanej przerwy.-->
						<!--Data Guard może zamienić każdą standby database w rolę głównej, minimalizując czas niedostępności powiązanej z przerwą.-->
					</p>
				</section>

				<section>
					<h2 style="color:#B2DFDB">Standby Database</h2>
					<p> Zapasowa baza danych jest tranzakcyjnie spójną kopią głównej bazy.

						<!--
						Spójność tranzakcyjna (Transactionally Consistent) - znaczy że istnieje snapshot bazy w punkcie czasu
						który zapewnia że wszystkoe scommitowane tranzakcje mają swoje odzwierciedlenie w bazie a nie scommitowane tranzakcje nie mają
						-->

						<!--
						Używając backup kopi głownej bazy można stworzyć do 9 zapasowych baz i włączyć je do konfiguracji Data Guarda.
						Po stworzeniu kopii, Data Guards automatycznie podtrzymuje każdą zapasową bazę poprzez przesyłanie "redo data"(redolog)
						z głownej bazy i następnie zastosowywując je w kopiach zapasowych.
						-->

						<!--
						Redo data (Redologi) - rejestrują wszystkie zatwierdzone (commit) tranzakcje bazy danych,
						czyli te operacje które coś zmieniają w bazie. Standardowo po instalacji bazy są trzy grupy plików redo logs o określonej wielkości.
						Jeśli pierwszy z plików się zapełni transakcje zapisywane są do następnego pliku i tak w koło.

						Gdy baza działa w bezpiecznym trybie archiwizacji logów, zapełniony plik jest archiwizowany
						czyli zmienia się w plik archive logs (*.arc).
						-->
					</p>

				</section>

				<section>
					<h2 style="color:#95cde7">Zapasowa baza danych moze być zarówną fizyczną kopią bazy jak i logiczną</h2>
					<ul>
						<li><h3>Fizyczna zapasowa baza danych</h3></li>
						<p>
							Dostarcza fizycznie identyczną kopię głownej bazy danych ze strukturami bazy,
							które są identyczne jak te w gównej bazie na zasadzie "block-for-block".
						</p>
						<p>
							Fizyczna kopia bazy jest synchronizowana z głowną bazą, poprzez <b>'Redo Apply'</b>
						</p>
						<!--
						Schemat bazy, włączając w to indeksy są te same. Fizyczna kopia bazy jest synchronizowana
						z głowną bazą, poprzez 'Redo Apply', które przywraca redo data otrzymane z głownej bazy
						i zastosowywuje the redo do fizycznej zapasowej bazy danych.

						Fizyczne kopie bazy mogą być uzywane w celach biznesowych innych niż zapobieganie utraty danych. (???)
						-->
						<li><h3>Logiczna zapasowa baza danych</h3></li>
						<p>
							Zawiera te same logiczne informacje jak produkcyjna baza danych, jednakże fizyczna organizacja i struktura danych może być inna.
						</p>
						<p>
							Logiczna zapasowa baza jest synchronizowana z  głowną  poprzez <b>'SQL Apply'</b>.
							<!--
							który przekształca dane otrzymane w redo z głownej bazy w SQL statements i wykonuje je na kopii bazy.
							-->
						</p>
						<!--
						Logiczna kopia bazy może być użyta w innych biznesowych celach jako dodatek, Co pozwala użytkownikowi na dostęp do zapytań z zapasowej bazy.
						Co więcej, używająć logicznej kopi , można upgradowac Oracle Database software i patchowac z praktycznie zerowym czasem przestoju.
						Logiczne kopie można używać równoczesnie do ochrony danych, reportowania i upgradów bazy.
						-->
					</ul>
				</section>

				<section>
					<h1><a style="color:#95cde7">Przykładowa konfiguracja</a></h1>
					<img src="https://docs.oracle.com/cd/B19306_01/server.102/b14239/img/ps_config.gif">
					<p>Na obrazku jest przedstawiona typowa konfiguraracja Oracle Data Guard która zawiera primary database i zapasową bazę danych.
					Zapasowa baza danych jest zamieszczona w innej lokalizacji niź główna baza danych. Zapasowa baza danych może znajdować się obok głównej bazy danych, ale Oracle
					rekomenduje umiejscowić zapasową bazę danych w innej lokalizacji.</p>
				</section>

				<section>
					<h2><a style="color:#95cde7">Data Guards Services</a></h2>

					<ul>
						<li> <h4>Redo Transport Services</h4>
							<p>
								kontroluje automatyczny transfer redo data z produkcyjnej bazy danych do jednego lub więcej instancji archiwizujacych.
							</p>
						</li>
						<li> <h4>Log Apply Services</h4>
							<p>
								Zastosowywuje redo data na zapasowych kopiach bazy danych do podtrzymania tranzakcyjnej synchronizacji z główną bazą danych.
							</p>
							<!--
							Redo data mogą być zastosowywane zarówno z archiwalnych plików red logów jak i
							gdy jest możliwe zastosowywanie w czasie rzeczywistym to nie czekamy na pliki żeby zostały zarchwizowane,
							tylko bezposrednio je przesyłamy.
							-->
						</li>
						<li> <h4>Role Transitions</h4>
							<p>
								Zmiana roli bazy danych z zapasowej w głowną lub z głównej w zapasową
								z wykorzystaniem zarówno operacji 'switchover' jak i 'failover'.
							</p>
						</li>
					</ul>
				</section>

				<section>
					<h2><a style="color:#95cde7">Redo Transport Services</a></h2>
					<p>
						kontroluje automatyczny transfer redo data z produkcyjnej bazy danych do jednego lub więcej instancji archiwizujacych.
					</p>
					<h3>Zadania</h3>
					<!-- Redo Transport Services wykonuje poniższe zadania:-->
					<ul>
						<li>Transport redo data z głownej bazy do kopi zapasowych w konfiguracji.</li>
						<li>Rozwiązywanie problemów powstałych wobez luk w redo logach spowodowanych awarią.</li>
						<li>Wdrążanie modów zabezpieczenia bazy</li>
						<li>Automatyczne wynajdywanie brakujących lub uszkodzonych zarchiwizowanych redo logów
							na zapasowym systemie i automatyczne zastępowanie zarchiwizowanych redo logów z innych baz danych </li>
						<!-- Głównych lub zapasowych -->
					</ul>
				</section>

				<section>
					<h2><a style="color:#95cde7">Log Apply Services</a></h2>
					<p>
						Zastosowywuje redo data na zapasowych kopiach bazy danych do podtrzymania tranzakcyjnej synchronizacji z główną bazą danych.
					</p>
					<!-- Pozwala również na dostęp read-only do danych-->
					<!--
						Główną różnicą pomiędzy fizyczną i logiczną kopią zapasową bazy danych jest sposób w jaki
						log apply services zastosowywuje zarchiwizowane redo logi

						Dla fizyczne kopie baz danych - Data Guard uzywa Redo Apply które zastosowywike redo data
						na zapasową baze uzywajac standardowegej techniki przywracania w Oraclowych bazach


						Dla Logicznych kopi zapasowych, Data Guards uzywa SQL Apply która najpierw przekształca
						otrzymane redo data w SQL statements i następnie wykonuje  generowane SQL statements na logicznej kopi.
					-->

				</section>

				<section>
					<h2><a style="color:#95cde7">Role Transitions</a></h2>
					<p>
						Wykorzystując Data Guard możemy zmienić rolę bazy danych z zapasowej w głowną lub z głównej w zapasową
						z wykorzystaniem zarówno operacji 'switchover' jak i 'failover'.
					</p>
						<ul>
							<li>
								Switchover jest odwróceniem roli pomiędzy głowną bazą danych i jedną z jej kopii. Switchover zapewnia zabezpieczenie przez utratą danych.
								<!--
									Jest głownie wykorzystywany dla zaplanowanych konserwacji głownego systemu. Podzczas switchover głowna baza jest przenoszona do roli zapasowej,
									a zapasowa do roli głownej. Przeniesienie występuje bez potrzeby odtwarzania którejkolwiek bazy
								-->
							</li>
							<li>
								Failover jest gdy głowna baza jest niedostepna.
								<!--
									Failover jest dokonywany tylko wtedy gdy zaistnieje sytuacja katastroficznego błedu głownej bazy
									i wynikiem failoveru jest przeniesienie kopi bazy do roli głownej. Wtedy administrator bazy może skonfigurować Data Guardsa żeby zapewnić brak utraty danych.

									Przenoszenie ról opisane powyżej są wykonywane poprzez ręczne użycie SQL statements.
								-->
							</li>
						</ul>
				</section>

				<section>
					<h2><a style="color:#95cde7">Data Guard Broker</a></h2>
					<p> Data Guard broker to dostarczany framework zarządzania automatyzujący tworzenie, podtrzymywanie i monitorowanie konfiguracji Data Guard.</p>
					<!-- Możęmy wyorzystywać albo graficzny interfejs Oracle Enterprise Manager albo command line Data Guarda do
					  -Tworzenia i uruchomenia konfiguracji Data Guard, zawierając ustawienia Redo Transport Service i Log Apply Services.
					   -Zarzadzanie całą konfiguracją Data Guarda z kążdego systemu w konfiguracji.
					   -Ulatwienie switchovers i failovers poprzez pozwalanie na uruchomienie cih za pomocą jednego przycisku w Oracle Enterprise Manager albo jednego polecenia
					   w interfejsie DGMGRL command line
					    - Pozwala na szybki start failovera kiedy glowna baza danych jest niedostępna. Kiedy szybki start failovera jest wlączony Data Guard
					    broker wyznacza jesli failover jest wymagany i inicjalizuje failover dla sprecyzowanej zapasowej bazy danych automatycznie przez co nie ryzykuje strata danych.
					   -->
					Dodatkowo , Oracle Enterprise Manager automatyzuje i upraszcza
					<ul>
						<li>Tworzyc fizyczne i logiczne zapasowe bazy danych z kopii backupu glownej bazy danych</li>
						<li>Dodawac nowe albo istniejace zapasowe bazy danych do istniejacej konfiguracji Data Guarda</li>
						<li>Monitorowanie statystycznych danych, wychwytywanie informacji diagnostycznych i
							szybkie wyszukiwanie problemow z centralizowanym monitorowaniem, testowaniem i narzedziami wydajnosciowymi. </li>
					</ul>
				</section>

				<section>
					<h2>Data Guard Protection Modes</h2>
					<p>W niektorych sytuacjach biznes nie moze sobie pozwolic na jakakolwiek utrate danych. W innych przypadkach dostepnosc bazy danych
					jest waniejsza od utraty danych.Niektore aplikacje wymagaja maksymalnej wydajnosci i moga tolerowac male utraty danych. teraz opiszemy 3 podstawowe
					tryby zabezpieczenia danych</p>
					<ul>
						<li>Maximum protection - zapewnia ze zadne dane nie beda stracone nawet jesli glowna baza zawiedzie.
						Zeby dostarczyc taki poziom zabezpieczenia redo data potrzebne do odtworzenia kazdej transakcji musza byc zapisane do obu - loklanych online redo legow i do zapasowych redo logow
						na prynajmniej jednej zapasowej bazie danych przed tym jak transakcja bedzie skomitowana.
						Zeby upewnic sie ze utrata danych nie nastapi glowna baza wylacza sie jesli usterka nie pozwala na zapisanie redo streama do zapasowych redo logow w co najmniej jednej transakcyjnie spojnej zapasowej bazy danych,</li>
					<li>
						Maximum availability - protetion mode ktory dostarcza najwyzszy poziom ochrony danych ktory jest mozliwy bez kompromitowania dostepnosci glownej bazy danych.
						Podobnie do maximum protectin mode  transakcja nie bedzie skomitowana dopoki redo potrzebne do przywracania tej transakcji nie bedzie zapisane do lokalnych online redo logow
						i do zapasowych redo logow na co najmniej jednej transakcyjnie spojnej zapasowej bazie danych.W odroznieniu od maximum protection mode glowna baza nie wylaczy sie jesli usterka
						nie pozwala na zapisanie redo streama do zapasowych redo logow. Natomiast, glowna baza danych operuje w maximum performance mode  dopoki usterka nie bedzie naprawiona i wszystkie luki
						w redo logach nie beda naprawione. Kiedy wszystkie luki beda naprawione glowna baza danych automatycznie wznowia dzialanie w maximum availability mode.

						Ten mode zapewnia ze dane nie zostna utracone jesli glowna baza danych zawiedzie, ale tylko jesli usterka nie przeszkodzi wyslaniu wszystkich redo logow od glownej bazy do chociazby jednej zapasowej bazy danych.
					</li>
						<li>
							Maximum performance - ten mode(domyslny) udostepnia najwyzszy poziom zabezpieczenia danych ktory jest mozliwy bez wplywu na wydajnosc
							glownej bazy danych. To jest realizowane poprzez pozwolenie transakcjom na komitowanie natychmiast po tym jak redo data potrzebne do
						</li>
					</ul>
				</section>

				<section>
					<h1><a style="color:#95cde7">Dziękujemy za uwagę</a></h1>
				</section>





			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				slideNumber: true,
				controls: true,
				progress: true,
				history: true,
				center: true,


				// The "normal" size of the presentation, aspect ratio will be preserved
				// when the presentation is scaled to fit different resolutions. Can be
				// specified using percentage units.
				width: 1200,
				height: 900,

				// Factor of the display size that should remain empty around the content
				margin: 0.1,

				// Bounds for smallest/largest possible scale to apply to content
				minScale: 0.5,
				maxScale: 1.5,

				transition: 'slide', // none/fade/slide/convex/concave/zoom

				multiplex: {
					// Example values. To generate your own, see the socket.io server instructions.
					secret: null, // null so the clients do not have control of the master presentation
					id: '1ea875674b17ca76', // id, obtained from socket.io server
					url: 'revealjs-51546.onmodulus.net:80' // Location of socket.io server
				},

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: '//cdn.socket.io/socket.io-1.3.5.js', async: true },
					{ src: 'plugin/multiplex/client.js', async: true }
				]
			});

		</script>

	</body>
</html>
